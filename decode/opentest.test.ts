import {
	assert,
	assertEquals,
	assertInstanceOf,
	assertNotStrictEquals,
	assertStrictEquals,
} from '@std/assert';
import { fixturePlist } from '../spec/fixture.ts';
import { PLArray } from '../array.ts';
import { PLDict } from '../dict.ts';
import { FORMAT_OPENSTEP, FORMAT_STRINGS } from '../format.ts';
import { PLString } from '../string.ts';
import type { PLType } from '../type.ts';
import { decodeOpenStep } from './openstep.ts';

Deno.test('Empty', () => {
	const te = new TextEncoder();
	const LS = String.fromCharCode(0x2028);
	const PS = String.fromCharCode(0x2029);
	const empties = [
		'',
		' ',
		'\r',
		'\n',
		'\r\n',
		'\n\r',
		'\t',
		'\x0B',
		'\f',
		'// comment',
		'/* comment */',
		...[
			'\r',
			'\n',
			'\r\n',
			'\n\r',
			LS,
			PS,
			'*',
			'//',
		].map((s) => `/* ${s} */`),
		LS,
		PS,
	];

	for (const a of empties) {
		for (const b of empties) {
			if (
				a.startsWith('//') && b.startsWith('/*') &&
				(
					b.includes('\r') ||
					b.includes('\n') ||
					b.includes(LS) ||
					b.includes(PS)
				)
			) {
				continue;
			}
			const str = `${a}${b}`;
			const tag = JSON.stringify(str);
			const dec = decodeOpenStep(te.encode(str));
			assertEquals(dec.format, FORMAT_STRINGS, tag);
			assert(PLDict.is(dec.plist), tag);
			assertEquals(dec.plist.size, 0, tag);
		}
	}
});

Deno.test('spec: array-0', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-0', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 0);
});

Deno.test('spec: array-1', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-1', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 1);
	const str = plist.get(0);
	assertInstanceOf(str, PLString);
	assertEquals(str.value, 'A');
});

Deno.test('spec: array-4', async () => {
	// TODO
});

Deno.test('spec: array-8', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-8', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 8);
	const all = new Set<PLString>();
	for (let i = 0; i < plist.length; i++) {
		const str: PLType = plist.get(i)!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, i % 2 ? 'B' : 'A');
		all.add(str);
	}
	assertEquals(all.size, 8);
});

Deno.test('spec: array-26', async () => {
	const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-26', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 26);
	for (let i = 0; i < plist.length; i++) {
		const str: PLType = plist.get(i)!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, alphabet[i]);
	}
});

Deno.test('spec: array-reuse', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-reuse', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 2);
	assertNotStrictEquals(plist.get(0), plist.get(1));
	for (let i = 0; i < plist.length; i++) {
		const a: PLType = plist.get(i)!;
		assertInstanceOf(a, PLArray);
		assertEquals(a.length, 2);
		for (let j = 0; j < a.length; j++) {
			const b: PLType = a.get(j)!;
			assertInstanceOf(b, PLString);
			assertEquals(b.value, j ? 'BBBB' : 'AAAA');
		}
	}
});

// TODO: data

Deno.test('spec: dict-empty', async () => {
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-empty', 'openstep'),
		);
		assertEquals(format, FORMAT_OPENSTEP);
		assertInstanceOf(plist, PLDict);
		assertEquals(plist.size, 0);
	}
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-empty', 'strings'),
		);
		assertEquals(format, FORMAT_STRINGS);
		assertInstanceOf(plist, PLDict);
		assertEquals(plist.size, 0);
	}
});

Deno.test('spec: dict-empties', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-empties', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const a = plist.find('array')!;
	assertInstanceOf(a, PLArray);
	assertEquals(a.length, 0);
	const d = plist.find('dict')!;
	assertInstanceOf(d, PLDict);
	assertEquals(d.size, 0);
});

Deno.test('spec: dict-26', async () => {
	const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-26', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 26);
	for (let i = 0; i < plist.size; i++) {
		const str: PLType = plist.find(alphabet[i])!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, alphabet[i].toLowerCase());
	}
});

Deno.test('spec: dict-long-key', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-long-key', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 1);
	const str: PLType = plist.find(
		'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789',
	)!;
	assertInstanceOf(str, PLString);
	assertEquals(str.value, '64');
});

Deno.test('spec: dict-unicode-key', async () => {
	// TODO
});

Deno.test('spec: dict-nesting', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-nesting', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);

	const A = plist.find('A')!;
	assertInstanceOf(A, PLDict);
	assertEquals(A.size, 2);

	const AA = A.find('AA')!;
	assertInstanceOf(AA, PLDict);
	assertEquals(AA.size, 2);

	const AAA = AA.find('AAA')!;
	assertInstanceOf(AAA, PLString);
	assertEquals(AAA.value, 'aaa');

	const AAB = AA.find('AAB')!;
	assertInstanceOf(AAB, PLString);
	assertEquals(AAB.value, 'aab');

	const AB = A.find('AB')!;
	assertInstanceOf(AB, PLDict);
	assertEquals(AB.size, 2);

	const ABA = AB.find('ABA')!;
	assertInstanceOf(ABA, PLString);
	assertEquals(ABA.value, 'aba');

	const ABB = AB.find('ABB')!;
	assertInstanceOf(ABB, PLString);
	assertEquals(ABB.value, 'abb');

	const B = plist.find('B')!;
	assertInstanceOf(B, PLDict);
	assertEquals(B.size, 2);

	const BA = B.find('BA')!;
	assertInstanceOf(BA, PLDict);
	assertEquals(BA.size, 2);

	const BAA = BA.find('BAA')!;
	assertInstanceOf(BAA, PLString);
	assertEquals(BAA.value, 'baa');

	const BAB = BA.find('BAB')!;
	assertInstanceOf(BAB, PLString);
	assertEquals(BAB.value, 'bab');

	const BB = B.find('BB')!;
	assertInstanceOf(BB, PLDict);
	assertEquals(BB.size, 2);

	const BBA = BB.find('BBA')!;
	assertInstanceOf(BBA, PLString);
	assertEquals(BBA.value, 'bba');

	const BBB = BB.find('BBB')!;
	assertInstanceOf(BBB, PLString);
	assertEquals(BBB.value, 'bbb');
});

Deno.test('spec: dict-order', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-order', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 7);

	const empty = plist.find('')!;
	assertInstanceOf(empty, PLString);
	assertEquals(empty.value, '0');

	const a = plist.find('a')!;
	assertInstanceOf(a, PLString);
	assertEquals(a.value, '1');

	const aa = plist.find('aa')!;
	assertInstanceOf(aa, PLString);
	assertEquals(aa.value, '2');

	const aaa = plist.find('aaa')!;
	assertInstanceOf(aaa, PLString);
	assertEquals(aaa.value, '3');

	const ab = plist.find('ab')!;
	assertInstanceOf(ab, PLString);
	assertEquals(ab.value, '4');

	const abb = plist.find('abb')!;
	assertInstanceOf(abb, PLString);
	assertEquals(abb.value, '5');

	const ac = plist.find('ac')!;
	assertInstanceOf(ac, PLString);
	assertEquals(ac.value, '6');
});

Deno.test('spec: dict-reuse', async () => {
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-reuse', 'openstep'),
		);
		assertEquals(format, FORMAT_OPENSTEP);
		assertInstanceOf(plist, PLDict);
		assertEquals(plist.size, 2);
		const AA = plist.find('AA')!;
		assertInstanceOf(AA, PLDict);
		{
			const AAAA = AA.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = AA.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		const BB = plist.find('BB')!;
		assertInstanceOf(BB, PLDict);
		{
			const AAAA = BB.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = BB.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		assertNotStrictEquals(AA, BB);
	}
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-reuse', 'strings'),
		);
		assertEquals(format, FORMAT_STRINGS);
		assertInstanceOf(plist, PLDict);
		const AA = plist.find('AA')!;
		assertInstanceOf(AA, PLDict);
		{
			const AAAA = AA.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = AA.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		const BB = plist.find('BB')!;
		assertInstanceOf(BB, PLDict);
		{
			const AAAA = BB.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = BB.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		assertNotStrictEquals(AA, BB);
	}
});

Deno.test('spec: dict-repeat', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-repeat', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 6);
	const expected = [
		['A', '11'],
		['B', '21'],
		['B', '22'],
		['C', '32'],
		['C', '31'],
		['C', '33'],
	];
	for (const [i, [k, v]] of [...plist].entries()) {
		assertInstanceOf(v, PLString);
		assertEquals(k.value, expected[i][0]);
		assertEquals(v.value, expected[i][1]);
	}
});

Deno.test('spec: string-empty', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('string-empty', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, '');
});

Deno.test('spec: string-ascii', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('string-ascii', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'ASCII');
});

Deno.test('spec: string-chars', async () => {
	// TODO
});

Deno.test('spec: string-unicode', async () => {
	// TODO
});

Deno.test('spec: string-long-unicode', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb2-divide', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb2-ohm', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb3-check', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb3-plus', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb4-robot', async () => {
	// TODO
});

Deno.test('spec: openstep-edge escapes-octal', async () => {
	// TODO
});

Deno.test('spec: openstep-edge all-types', async () => {
	// TODO
});

Deno.test('spec: strings-edge all-types', async () => {
	// TODO
});

Deno.test('spec: openstep-edge shortcut', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'shortcut'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 5);
	const A = plist.findKey('A')!;
	assertNotStrictEquals(A, plist.get(A)!);
	const B = plist.findKey('B')!;
	assertStrictEquals(B, plist.get(B)!);
	const C = plist.findKey('C')!;
	assertNotStrictEquals(C, plist.get(C)!);
	const D = plist.findKey('D')!;
	assertNotStrictEquals(D, plist.get(D)!);
	const E = plist.findKey('E')!;
	assertStrictEquals(E, plist.get(E)!);
});

Deno.test('spec: strings-edge shortcut', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'shortcut'),
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 5);
	const A = plist.findKey('A')!;
	assertNotStrictEquals(A, plist.get(A)!);
	const B = plist.findKey('B')!;
	assertStrictEquals(B, plist.get(B)!);
	const C = plist.findKey('C')!;
	assertNotStrictEquals(C, plist.get(C)!);
	const D = plist.findKey('D')!;
	assertNotStrictEquals(D, plist.get(D)!);
	const E = plist.findKey('E')!;
	assertStrictEquals(E, plist.get(E)!);
});
