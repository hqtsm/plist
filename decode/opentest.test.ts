import {
	assert,
	assertEquals,
	assertInstanceOf,
	assertNotStrictEquals,
	assertStrictEquals,
} from '@std/assert';
import { fixturePlist } from '../spec/fixture.ts';
import { PLArray } from '../array.ts';
import { PLDict } from '../dict.ts';
import { FORMAT_OPENSTEP, FORMAT_STRINGS } from '../format.ts';
import { unquoted } from '../pri/openstep.ts';
import { PLString } from '../string.ts';
import type { PLType } from '../type.ts';
import { decodeOpenStep } from './openstep.ts';
import { PLData } from '../data.ts';

Deno.test('Empty', () => {
	const te = new TextEncoder();
	const LS = String.fromCharCode(0x2028);
	const PS = String.fromCharCode(0x2029);
	const empties = [
		'',
		' ',
		'\r',
		'\n',
		'\r\n',
		'\n\r',
		'\t',
		'\x0B',
		'\f',
		'//',
		'// comment',
		'/**/',
		'/* comment */',
		...[
			'\r',
			'\n',
			'\r\n',
			'\n\r',
			LS,
			PS,
			'*',
			'//',
		].map((s) => `/* ${s} */`),
		LS,
		PS,
	];

	for (const a of empties) {
		for (const b of empties) {
			if (
				a.startsWith('//') && b.startsWith('/*') &&
				(
					b.includes('\r') ||
					b.includes('\n') ||
					b.includes(LS) ||
					b.includes(PS)
				)
			) {
				continue;
			}
			const str = `${a}${b}`;
			const tag = JSON.stringify(str);
			const dec = decodeOpenStep(te.encode(str));
			assertEquals(dec.format, FORMAT_STRINGS, tag);
			assert(PLDict.is(dec.plist), tag);
			assertEquals(dec.plist.size, 0, tag);
		}
	}
});

Deno.test('spec: array-0', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-0', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 0);
});

Deno.test('spec: array-1', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-1', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 1);
	const str = plist.get(0);
	assertInstanceOf(str, PLString);
	assertEquals(str.value, 'A');
});

Deno.test('spec: array-4', async () => {
	const aa = new Uint8Array([0x61, 0x61]);
	const bb = new Uint8Array([0x62, 0x62]);
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-4', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 4);
	for (let i = 0; i < plist.length; i++) {
		const str: PLType = plist.get(i)!;
		assertInstanceOf(str, PLData);
		assertEquals(new Uint8Array(str.buffer), i % 2 ? bb : aa);
	}
});

Deno.test('spec: array-8', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-8', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 8);
	const all = new Set<PLString>();
	for (let i = 0; i < plist.length; i++) {
		const str: PLType = plist.get(i)!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, i % 2 ? 'B' : 'A');
		all.add(str);
	}
	assertEquals(all.size, 8);
});

Deno.test('spec: array-26', async () => {
	const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-26', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 26);
	for (let i = 0; i < plist.length; i++) {
		const str: PLType = plist.get(i)!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, alphabet[i]);
	}
});

Deno.test('spec: array-reuse', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('array-reuse', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 2);
	assertNotStrictEquals(plist.get(0), plist.get(1));
	for (let i = 0; i < plist.length; i++) {
		const a: PLType = plist.get(i)!;
		assertInstanceOf(a, PLArray);
		assertEquals(a.length, 2);
		for (let j = 0; j < a.length; j++) {
			const b: PLType = a.get(j)!;
			assertInstanceOf(b, PLString);
			assertEquals(b.value, j ? 'BBBB' : 'AAAA');
		}
	}
});

Deno.test('spec: data-0', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-0', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 0);
});

Deno.test('spec: data-1', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-1', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 1);
	assertEquals(
		new Uint8Array(plist.buffer),
		new Uint8Array([0x61]),
	);
});

Deno.test('spec: data-2', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-2', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 2);
	assertEquals(
		new Uint8Array(plist.buffer),
		new Uint8Array([0x61, 0x62]),
	);
});

Deno.test('spec: data-3', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-3', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 3);
	assertEquals(
		new Uint8Array(plist.buffer),
		new Uint8Array([0x61, 0x62, 0x63]),
	);
});

Deno.test('spec: data-4', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-4', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 4);
	assertEquals(
		new Uint8Array(plist.buffer),
		new Uint8Array([0x61, 0x62, 0x63, 0x64]),
	);
});

Deno.test('spec: data-14', async () => {
	const chars = [...'abcdefghijklmn'].map((c) => c.charCodeAt(0));
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-14', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 14);
	assertEquals(
		new Uint8Array(plist.buffer),
		new Uint8Array(chars),
	);
});

Deno.test('spec: data-15', async () => {
	const chars = [...'abcdefghijklmno'].map((c) => c.charCodeAt(0));
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-15', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 15);
	assertEquals(
		new Uint8Array(plist.buffer),
		new Uint8Array(chars),
	);
});

Deno.test('spec: data-255', async () => {
	const bytes = new Uint8Array(255);
	for (let i = 0; i < 255; i++) {
		bytes[i] = i;
	}
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-255', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 255);
	assertEquals(
		new Uint8Array(plist.buffer),
		bytes,
	);
});

Deno.test('spec: data-256', async () => {
	const bytes = new Uint8Array(256);
	for (let i = 0; i < 256; i++) {
		bytes[i] = i;
	}
	const { format, plist } = decodeOpenStep(
		await fixturePlist('data-256', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLData);
	assertEquals(plist.byteLength, 256);
	assertEquals(
		new Uint8Array(plist.buffer),
		bytes,
	);
});

Deno.test('spec: dict-empty', async () => {
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-empty', 'openstep'),
		);
		assertEquals(format, FORMAT_OPENSTEP);
		assertInstanceOf(plist, PLDict);
		assertEquals(plist.size, 0);
	}
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-empty', 'strings'),
		);
		assertEquals(format, FORMAT_STRINGS);
		assertInstanceOf(plist, PLDict);
		assertEquals(plist.size, 0);
	}
});

Deno.test('spec: dict-empties', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-empties', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const a = plist.find('array')!;
	assertInstanceOf(a, PLArray);
	assertEquals(a.length, 0);
	const d = plist.find('dict')!;
	assertInstanceOf(d, PLDict);
	assertEquals(d.size, 0);
});

Deno.test('spec: dict-26', async () => {
	const alphabet = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-26', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 26);
	for (let i = 0; i < plist.size; i++) {
		const str: PLType = plist.find(alphabet[i])!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, alphabet[i].toLowerCase());
	}
});

Deno.test('spec: dict-long-key', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-long-key', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 1);
	const str: PLType = plist.find(
		'ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz 0123456789',
	)!;
	assertInstanceOf(str, PLString);
	assertEquals(str.value, '64');
});

Deno.test('spec: dict-unicode-key', async () => {
	// TODO
});

Deno.test('spec: dict-nesting', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-nesting', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);

	const A = plist.find('A')!;
	assertInstanceOf(A, PLDict);
	assertEquals(A.size, 2);

	const AA = A.find('AA')!;
	assertInstanceOf(AA, PLDict);
	assertEquals(AA.size, 2);

	const AAA = AA.find('AAA')!;
	assertInstanceOf(AAA, PLString);
	assertEquals(AAA.value, 'aaa');

	const AAB = AA.find('AAB')!;
	assertInstanceOf(AAB, PLString);
	assertEquals(AAB.value, 'aab');

	const AB = A.find('AB')!;
	assertInstanceOf(AB, PLDict);
	assertEquals(AB.size, 2);

	const ABA = AB.find('ABA')!;
	assertInstanceOf(ABA, PLString);
	assertEquals(ABA.value, 'aba');

	const ABB = AB.find('ABB')!;
	assertInstanceOf(ABB, PLString);
	assertEquals(ABB.value, 'abb');

	const B = plist.find('B')!;
	assertInstanceOf(B, PLDict);
	assertEquals(B.size, 2);

	const BA = B.find('BA')!;
	assertInstanceOf(BA, PLDict);
	assertEquals(BA.size, 2);

	const BAA = BA.find('BAA')!;
	assertInstanceOf(BAA, PLString);
	assertEquals(BAA.value, 'baa');

	const BAB = BA.find('BAB')!;
	assertInstanceOf(BAB, PLString);
	assertEquals(BAB.value, 'bab');

	const BB = B.find('BB')!;
	assertInstanceOf(BB, PLDict);
	assertEquals(BB.size, 2);

	const BBA = BB.find('BBA')!;
	assertInstanceOf(BBA, PLString);
	assertEquals(BBA.value, 'bba');

	const BBB = BB.find('BBB')!;
	assertInstanceOf(BBB, PLString);
	assertEquals(BBB.value, 'bbb');
});

Deno.test('spec: dict-order', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-order', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 7);

	const empty = plist.find('')!;
	assertInstanceOf(empty, PLString);
	assertEquals(empty.value, '0');

	const a = plist.find('a')!;
	assertInstanceOf(a, PLString);
	assertEquals(a.value, '1');

	const aa = plist.find('aa')!;
	assertInstanceOf(aa, PLString);
	assertEquals(aa.value, '2');

	const aaa = plist.find('aaa')!;
	assertInstanceOf(aaa, PLString);
	assertEquals(aaa.value, '3');

	const ab = plist.find('ab')!;
	assertInstanceOf(ab, PLString);
	assertEquals(ab.value, '4');

	const abb = plist.find('abb')!;
	assertInstanceOf(abb, PLString);
	assertEquals(abb.value, '5');

	const ac = plist.find('ac')!;
	assertInstanceOf(ac, PLString);
	assertEquals(ac.value, '6');
});

Deno.test('spec: dict-reuse', async () => {
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-reuse', 'openstep'),
		);
		assertEquals(format, FORMAT_OPENSTEP);
		assertInstanceOf(plist, PLDict);
		assertEquals(plist.size, 2);
		const AA = plist.find('AA')!;
		assertInstanceOf(AA, PLDict);
		{
			const AAAA = AA.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = AA.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		const BB = plist.find('BB')!;
		assertInstanceOf(BB, PLDict);
		{
			const AAAA = BB.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = BB.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		assertNotStrictEquals(AA, BB);
	}
	{
		const { format, plist } = decodeOpenStep(
			await fixturePlist('dict-reuse', 'strings'),
		);
		assertEquals(format, FORMAT_STRINGS);
		assertInstanceOf(plist, PLDict);
		const AA = plist.find('AA')!;
		assertInstanceOf(AA, PLDict);
		{
			const AAAA = AA.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = AA.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		const BB = plist.find('BB')!;
		assertInstanceOf(BB, PLDict);
		{
			const AAAA = BB.find('AAAA')!;
			assertInstanceOf(AAAA, PLString);
			assertEquals(AAAA.value, '1111');
			const BBBB = BB.find('BBBB')!;
			assertInstanceOf(BBBB, PLString);
			assertEquals(BBBB.value, '2222');
		}
		assertNotStrictEquals(AA, BB);
	}
});

Deno.test('spec: dict-repeat', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('dict-repeat', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 6);
	const expected = [
		['A', '11'],
		['B', '21'],
		['B', '22'],
		['C', '32'],
		['C', '31'],
		['C', '33'],
	];
	for (const [i, [k, v]] of [...plist].entries()) {
		assertInstanceOf(v, PLString);
		assertEquals(k.value, expected[i][0]);
		assertEquals(v.value, expected[i][1]);
	}
});

Deno.test('spec: string-empty', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('string-empty', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, '');
});

Deno.test('spec: string-ascii', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('string-ascii', 'openstep'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'ASCII');
});

Deno.test('spec: string-chars', async () => {
	// TODO
});

Deno.test('spec: string-unicode', async () => {
	// TODO
});

Deno.test('spec: string-long-unicode', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb2-divide', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb2-ohm', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb3-check', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb3-plus', async () => {
	// TODO
});

Deno.test('spec: string-utf8-mb4-robot', async () => {
	// TODO
});

Deno.test('spec: openstep-edge escapes-octal', async () => {
	// TODO
});

Deno.test('spec: openstep-edge all-types', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'all-types'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 4);
	const STRING = plist.find('STRING')!;
	assertInstanceOf(STRING, PLString);
	assertEquals(STRING.value, 'Example');
	const DICT = plist.find('DICT')!;
	assertInstanceOf(DICT, PLDict);
	assertEquals(DICT.size, 2);
	const A = DICT.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'a');
	const B = DICT.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'b');
	const ARRAY = plist.find('ARRAY')!;
	assertInstanceOf(ARRAY, PLArray);
	assertEquals(ARRAY.length, 3);
	for (let i = 0; i < ARRAY.length; i++) {
		const str: PLType = ARRAY.get(i)!;
		assertInstanceOf(str, PLString);
		assertEquals(str.value, `${i + 1}`, `ARRAY[${i}]`);
	}
	const DATA = plist.find('DATA')!;
	assertInstanceOf(DATA, PLData);
	assertEquals(
		new Uint8Array(DATA.buffer),
		new Uint8Array([0x01, 0x23, 0x45, 0x67]),
	);
});

Deno.test('spec: openstep-edge array-comments-block', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'array-comments-block'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 2);
	const A = plist.get(0)!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'A');
	const B = plist.get(1)!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'B');
});

Deno.test('spec: openstep-edge array-comments-line', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'array-comments-line'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 2);
	const A = plist.get(0)!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'A');
	const B = plist.get(1)!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'B');
});

Deno.test('spec: openstep-edge array-junk-error', async () => {
	// TODO
});

Deno.test('spec: openstep-edge array-trailing-comma', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'array-trailing-comma'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, 2);
	const A = plist.get(0)!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'A');
	const B = plist.get(1)!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'B');
});

Deno.test('spec: openstep-edge data-caps', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'data-caps'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	const ALL = plist.find('ALL')!;
	assertInstanceOf(ALL, PLData);
	assertEquals(
		new Uint8Array(ALL.buffer),
		new Uint8Array([
			0x01,
			0x23,
			0x45,
			0x67,
			0x89,
			0xab,
			0xcd,
			0xef,
			0xab,
			0xcd,
			0xef,
		]),
	);
});

Deno.test('spec: openstep-edge data-comments-block', async () => {
	// TODO
});

Deno.test('spec: openstep-edge data-comments-line', async () => {
	// TODO
});

Deno.test('spec: openstep-edge data-spacing', async () => {
	// TODO
});

Deno.test('spec: openstep-edge dict-comments-block', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'dict-comments-block'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'A');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'B');
});

Deno.test('spec: openstep-edge dict-comments-line', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'dict-comments-line'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'A');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'B');
});

Deno.test('spec: openstep-edge dict-spacing', async () => {
	const chars = 'ABCDEFG';
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'dict-spacing'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, chars.length);
	for (const char of chars) {
		const tag = `char: ${char}`;
		const s: PLType = plist.find(char)!;
		assertInstanceOf(s, PLString, tag);
		assertEquals(s.value, char, tag);
	}
});

Deno.test('spec: openstep-edge escapes-double', async () => {
	// TODO
});

Deno.test('spec: openstep-edge escapes-octal', async () => {
	// TODO
});

Deno.test('spec: openstep-edge escapes-repeat', async () => {
	// TODO
});

Deno.test('spec: openstep-edge escapes-single', async () => {
	// TODO
});

Deno.test('spec: openstep-edge escapes-unicode-partial', async () => {
	// TODO
});

Deno.test('spec: openstep-edge legacy-dict-opt-sc', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'legacy-dict-opt-sc'),
		{
			allowMissingSemi: true,
		},
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'Alpha');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'Beta');
});

Deno.test('spec: openstep-edge not-comment', async () => {
	const values = [
		'/',
		'A//',
		'A//B',
		'//',
		'//',
		'/*',
		'/*',
		'/* */',
		'/* */',
	];
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'not-comment'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLArray);
	assertEquals(plist.length, values.length);
	for (let i = 0; i < plist.length; i++) {
		const tag = `index: ${i}, value: ${values[i]}`;
		const str: PLType = plist.get(i)!;
		assertInstanceOf(str, PLString, tag);
		assertEquals(str.value, values[i], tag);
	}
});

Deno.test('spec: openstep-edge quotes', async () => {
	// TODO
});

Deno.test('spec: openstep-edge shortcut', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'shortcut'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 5);
	const A = plist.findKey('A')!;
	assertNotStrictEquals(A, plist.get(A)!);
	const B = plist.findKey('B')!;
	assertStrictEquals(B, plist.get(B)!);
	const C = plist.findKey('C')!;
	assertNotStrictEquals(C, plist.get(C)!);
	const D = plist.findKey('D')!;
	assertNotStrictEquals(D, plist.get(D)!);
	const E = plist.findKey('E')!;
	assertStrictEquals(E, plist.get(E)!);
});

Deno.test('spec: openstep-edge string-junk-error', async () => {
	// TODO
});

Deno.test('spec: openstep-edge string-multiline', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'string-multiline'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'Line 1\nLine 2\nLine 3\n');
});

Deno.test('spec: openstep-edge string-quoted-comments-block', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'string-quoted-comments-block'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'TEST');
});

Deno.test('spec: openstep-edge string-quoted-comments-line', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'string-quoted-comments-line'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'TEST');
});

Deno.test('spec: openstep-edge string-unquoted-comments-block', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'string-unquoted-comments-block'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'TEST');
});

Deno.test('spec: openstep-edge string-unquoted-comments-line', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'string-unquoted-comments-line'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLString);
	assertEquals(plist.value, 'TEST');
});

Deno.test('spec: openstep-edge unescaped-ascii', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'unescaped-ascii'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	for (let i = 0; i < 128; i++) {
		if (i === 92) {
			continue;
		}
		const char = String.fromCharCode(i);
		const tag = `char: ${i} (${JSON.stringify(char)})`;
		const v: PLType = plist.find(char)!;
		assertInstanceOf(v, PLString, tag);
		assertEquals(v.value, `${i}`, tag);
	}
});

Deno.test('spec: openstep-edge unescaped-utf8', async () => {
	// TODO
});

Deno.test('spec: openstep-edge unquotables', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('openstep-edge', 'unquotables'),
	);
	assertEquals(format, FORMAT_OPENSTEP);
	assertInstanceOf(plist, PLDict);
	for (let i = 0; i < 256; i++) {
		const char = String.fromCharCode(i);
		const tag = `char: ${i} (${JSON.stringify(char)})`;
		if (unquoted(i)) {
			const v: PLType = plist.find(char)!;
			assertInstanceOf(v, PLString, tag);
			assertEquals(v.value, char, tag);
		} else {
			assertStrictEquals(plist.find(char), undefined, tag);
		}
	}
});

Deno.test('spec: strings-edge comments', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'comments'),
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, '1');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, '2');
});

Deno.test('spec: strings-edge shortcut', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'shortcut'),
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 5);
	const A = plist.findKey('A')!;
	assertNotStrictEquals(A, plist.get(A)!);
	const B = plist.findKey('B')!;
	assertStrictEquals(B, plist.get(B)!);
	const C = plist.findKey('C')!;
	assertNotStrictEquals(C, plist.get(C)!);
	const D = plist.findKey('D')!;
	assertNotStrictEquals(D, plist.get(D)!);
	const E = plist.findKey('E')!;
	assertStrictEquals(E, plist.get(E)!);
});

Deno.test('spec: strings-edge junk-data', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'junk-null'),
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'Alpha');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'Beta');
});

Deno.test('spec: strings-edge junk-em', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'junk-em'),
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'Alpha');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'Beta');
});

Deno.test('spec: strings-edge junk-null', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'junk-null'),
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'Alpha');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'Beta');
});

Deno.test('spec: strings-edge legacy-dict-opt-sc', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'legacy-dict-opt-sc'),
		{
			allowMissingSemi: true,
		},
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'Alpha');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'Beta');
});

Deno.test('spec: strings-edge legacy-junk', async () => {
	const { format, plist } = decodeOpenStep(
		await fixturePlist('strings-edge', 'legacy-junk'),
		{
			allowMissingSemi: true,
		},
	);
	assertEquals(format, FORMAT_STRINGS);
	assertInstanceOf(plist, PLDict);
	assertEquals(plist.size, 2);
	const A = plist.find('A')!;
	assertInstanceOf(A, PLString);
	assertEquals(A.value, 'Alpha');
	const B = plist.find('B')!;
	assertInstanceOf(B, PLString);
	assertEquals(B.value, 'Beta');
});
